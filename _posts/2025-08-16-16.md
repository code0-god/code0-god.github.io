---
title: "[C++] Values (lvalue / rvalue / xvalue / prvalue / glvalue)"
author: zerogod
date: 2025-08-25 16:48 +0900
categories: [C/C++, Language, Expressions]
tags: [expressions, value-category, lvalue, xvalue, prvalue, glvalue, rvalue, move-semantics, conversions, overload-resolution]
render_with_liquid: true
---
## **Abstract**
{% code_runner id="1" language="cpp"%}
{% file "value.cpp" %}
int main(){
  int num = 0;
  int& ref1 = num; // OK!
  int& ref2 = 0; // Error!
  return 0;
}
{% endfile %}
{% endcode_runner %}

In the above code, the compiler fails to compile and returns an error: ***cannot bind non-const lvalue reference of type ‘int&’ to an rvalue of type ‘int’***. In C/C++, <u>the initial value of a reference to non-const must be an lvalue.</u>
This post provides these value categories for understanding C++'s complicated value semantics.

---

## **Summary**
**Every C++ expression has a type and a value category.**   
- **Primary category**: `lvalue`, `xvalue`, `prvalue`.   
- **Mixed category**: `glvalue` = lvalue ∪ xvalue, `rvalue` = prvalue ∪ xvalue. 

These categories steer **overload resolution**, **move semantics**, and **lifetime**.

> **two-axis classification**   
> - `Identity` (designates a specific storage location): yes &rarr; *`glvalue`* (lvalue/xvalue)
> - `Move-eligible`: yes &rarr; *`rvalue`* (prvalue/xvalue)

---

## **1. Definition**
In C++, every **expression** has a **value category**:

| Classification | Move-eligible | Not Move-eligible |
| :------------: | :-----------: | :---------------: |
| Has identity   |   `xvalue`    |      `lvalue`     |
|  No identity   |   `prvalue`   |         -         | 

*`Identity`* means the expression designates a specific **storage location** (it has a stable address/identity).   
Value categories are also grouped into **composite sets** and **primary categories**:

- **Mixed category:**
  - `glvalue`: expressions **with identity**. 
  - `rvalue`: expressions treated as **move-eligible**.

- **Primary category:**
  - `lvalue`: **has** identity; usually addressable; **not** treated as move-eligible by default.
  - `xvalue`: **has** identity; **expiring** (resource-reusable); move-eligible.
  - `prvalue`: **no** identity; denotes a **result value/object** (since C++17).

---

### 1.1. lvalue
An `lvalue` is a `glvalue` that is not an `xvalue`&mdash;i.e., an expression with **identity** (designates a specific object, bit-field, or function) that is **not** treated as **move-eligible** in overload resolution.

{% code_runner id="2" language="cpp"%}
{% file "lvalue.cpp" %}
#include <iostream>
#include <type_traits>
#include <utility>

using namespace std;

static int g = 10;

int& foo() { // returns an lvalue (int&)
  ++g;
  return g;
}

int main() {
  cout << boolalpha;

  int a = 10, b = 10, c = 10;


  // decltype((expr)) encodes value category:
  // lvalue -> T&, xvalue -> T&&, prvalue -> T (non-reference)

  // 1. Value category test uses decltype((expr)) — note the double parenthesis.
  static_assert(std::is_lvalue_reference_v<decltype((a))>, "a must be lvalue");
  cout << "is 'a' an lvalue?: " << std::is_lvalue_reference_v<decltype((a))> << '\n'; // true

  // 2. A function that returns T& yields an lvalue expression.
  static_assert(std::is_lvalue_reference_v<decltype((foo()))>, "foo() must be lvalue");
  cout << "is 'foo()' an lvalue?: " << std::is_lvalue_reference_v<decltype((foo()))> << '\n'; // true

  // 3. Built-in address-of works on lvalues (bit-fields are an exception).
  int *p_local = &a;            // OK: a is lvalue
  int *p_foo = &foo();        // OK: foo() is lvalue (int&)
  (void)p_local; (void)p_foo;

  // 4. Pre-increment/decrement require a 'modifiable lvalue'; the result is an lvalue.
  ++a; // pre-increment

  // 5. Subscript expressions are lvalues (initialize to avoid UB).
  int d[4] = { 0, 1, 2, 3 };
  cout << "d[1] before = " << d[1] << '\n';
  d[1] = 42;  // assign through lvalue
  cout << "d[1] after = " << d[1] << '\n';

  // 6. Conditional operator: if both operands are lvalues convertible to a common lvalue type, the result is an lvalue.
  (a ? b : c) = 77; 
  cout << "b=" << b << ", c=" << c << '\n'; // if a!=0 → b=77, else c=77

  // 7. Modify the global via an lvalue-returning function.
  foo() = 43;
  cout << "global g = " << g << '\n';
}
{% endfile %}
{% endcode_runner %}

**Common sources of lvalues:**
- Named objects (`x`), dereference (`*p`), subscript (`a[i]`), member access on an lvalue base (`obj.m`), bit-fields
- Function designators (e.g., `f` used for a call)
- Result of pre-increment/decrement
- String literals (`"text"`) &mdash; `const char[N]` array lvalues

**What lvalues can do (with caveats):**
- Appear as the **left operand of built-in assignment** if they are modifiable lvalues (not `const`, not a function, bit-fields have restrictions).
- Have their **address taken** with built-in `&` (bit-fields cannot; user-defined `operator&` may affect this).
- Often denote entities whose **lifetime outlives** the expression; however, an `lvalue` can also designate a **subobject of a temporary**, whose lifetime ends at the end of the full-expression.


### 1.2. xvalue
An **xvalue** is a **glvalue** that **denotes an “expiring” object or subobject**: it has **identity** (an addressable storage location) **and** is **treated as move-eligible** in overload resolution (binds to `T&&`). Typical producers are `std::move(x)`, `static_cast<T&&>(x)`, and calls that return `T&&`. Member access on a **class rvalue** also yields xvalues (C++17: via temporary materialization).

{% code_runner id="3" language="cpp" %}
{% file "xvalue.cpp" %}
#include <iostream>
#include <type_traits>
#include <utility>
#include <string>
using namespace std;

// Safe sources of xvalue
int g = 0;
int&  lref() { return g; }                              // lvalue result
int&& rref_to_g() { return static_cast<int&&>(g); }     // xvalue result (T&&)

struct S { int m = 42; };

int main() {
cout << boolalpha;

int a = 10;

// decltype((expr)) encodes value category:
// lvalue -> T&, xvalue -> T&&, prvalue -> T (non-reference)

// 1. std::move(x) produces an xvalue (glvalue with identity, move-eligible)
cout << "std::move(a) is xvalue?: " 
     << std::is_rvalue_reference_v<decltype((std::move(a)))> << '\n';   // true

// 2. A function returning T&& yields an xvalue
cout << "rref_to_g() is xvalue?: " 
     << std::is_rvalue_reference_v<decltype((rref_to_g()))> << '\n';    // true

// 3. Member access on a class rvalue is an xvalue (C++17 temporary materialization)
cout << "S{}.m is xvalue?: " 
     << std::is_rvalue_reference_v<decltype((S{}.m))> << '\n'; // true

// 4. Binds to T&& (move sinks), not to non-const T&
auto sink = [](int&&) { cout << "bound to int&&\n"; };
sink(std::move(a));                // OK
// int& bad = std::move(a);       // ill-formed: non-const lvalue ref can't bind to xvalue

// 5. Built-in address-of on an xvalue is ill-formed
// int* p = &std::move(a);        // error: cannot take address of rvalue (built-in &)
// (A class may overload operator&, but that's separate from the built-in rule.)

// 6. Moved-from objects are still valid but unspecified
std::string s = "hi";
std::string t = std::move(s);      // s is moved-from but remains a valid object
cout << "moved-from string still valid? " << (s.size() >= 0) << '\n';

(void)lref(); // silence ODR-use
}
{% endfile %}
{% endcode_runner %}

**Common sources of xvalues:**
- `std::move(x)`, `static_cast<T&&>(x)`
- Function calls that **return `T&&`**
- **Member access** on a **class rvalue** (e.g., `S{}.m`, `std::move(obj).m`) &mdash; C++17 temporary materialization

**What xvalues can do (with caveats):**
- **Bind** to `T&&` (and to `const T&`), **not** to non-const `T&`.
- Dispatch to **`&&`-qualified member functions** (`obj` as rvalue).
- Are **glvalues**: they **have identity** (you’re still talking about *that* object).
- **Cannot** be the **left operand of built-in assignment** (needs a modifiable lvalue).
- **Built-in `&`** (address-of) is **not applicable** to rvalues (including xvalues).
  *(A class may overload `operator&`, but that's separate from the built-in rule.)*

**Lifetime notes (important):**
- `std::move(x)` produces an xvalue **referring to `x` itself**. `x` does **not** vanish; it stays alive but may be in a moved-from state (valid but unspecified).
- When a **class prvalue** is used where a glvalue is required, **temporary materialization** creates a temporary object and the resulting expression is an **xvalue** designating that temporary; **that temporary dies at the end of the full-expression**.

### 1.3. prvalue
A **prvalue** (*pure rvalue*) is an expression with **no identity**: it doesn’t designate a specific storage location. It is an **rvalue**, so it **binds to `T&&` and `const T&`**, but **not** to non-const `T&`.   
Built-in address-of `&` **does not apply** to a prvalue.

Since **C++17**, **class/array prvalues denote a result object**; when a **glvalue is required** (e.g., binding to a reference, member access), a **temporary materialization conversion** creates a temporary and the expression yields an **xvalue** designating that temporary.

{% code_runner id="4" language="cpp" %}
{% file "prvalue.cpp" %}
#include <iostream>
#include <type_traits>
#include <utility>
using namespace std;

struct S { int m = 42; };
S make() { return S{}; } // returns by value -> prvalue

int main() {
cout << boolalpha;

int a = 10, b = 20;

// decltype((expr)) encodes value category:
// lvalue -> T&, xvalue -> T&&, prvalue -> T (non-reference)

// 1. Literals and arithmetic/comparison results are prvalues
cout << "42 is prvalue?: "
     << (!std::is_lvalue_reference_v<decltype((42))> &&
         !std::is_rvalue_reference_v<decltype((42))>) << '\n';

cout << "a + b is prvalue?: "
     << (!std::is_lvalue_reference_v<decltype((a + b))> &&
         !std::is_rvalue_reference_v<decltype((a + b))>) << '\n';

cout << "a < b is prvalue?: "
     << (!std::is_lvalue_reference_v<decltype((a < b))> &&
         !std::is_rvalue_reference_v<decltype((a < b))>) << '\n';

// 2. Post-increment/decrement yield prvalues (pre-inc/dec yield lvalues)
cout << "a++ is prvalue?: "
     << (!std::is_lvalue_reference_v<decltype((a++))> &&
         !std::is_rvalue_reference_v<decltype((a++))>) << '\n';

// 3. By-value function calls are prvalues
cout << "make() is prvalue?: "
     << (!std::is_lvalue_reference_v<decltype((make()))> &&
         !std::is_rvalue_reference_v<decltype((make()))>) << '\n';

// 4. Class prvalue + member access (since C++17): materialize -> xvalue
cout << "S{} is prvalue?: "
     << (!std::is_lvalue_reference_v<decltype((S{}))> &&
         !std::is_rvalue_reference_v<decltype((S{}))>) << '\n';

cout << "S{}.m is xvalue?: "
     << ( std::is_rvalue_reference_v<decltype((S{}.m))> ) << '\n';

// 5. Built-in address-of is ill-formed for prvalues
// int* p = &(a + b); // error
// auto q = &S{}; // error
}
{% endfile %}
{% endcode_runner %}

**Common sources of prvalues**
- **Non-string literals**: `42`, `3.14`, `true`, `'c'`, `nullptr` *(string literals are array **lvalues**)*
- **Arithmetic / relational / logical / bitwise** results: `a + b`, `a < b`, `x && y`, `x | y`, …
- **Post-increment/decrement**: `x++`, `x--` *(pre-inc/dec `++x/--x` are **lvalues**)*
- **By-value function calls**: `T f(); f()`
- **Temporary objects**: `T{...}`, `T(...)`, `S{}` *(class prvalue; member access yields **xvalue**)*
- **Lambda expressions**: `[&]{ return 0; }` (closure object prvalue)
- Many conditional expressions `cond ? e1 : e2` (when they don’t meet lvalue rules)

**What prvalues can do (with caveats)**
- **Bind** to `T&&` and `const T&`; **cannot** bind to non-const `T&`.
- Appear on the **right-hand side** of assignment; initialize objects/parameters.
- **Built-in `&`** is **not allowed** on prvalues (`&(a+b)` ill-formed).
- **Member access on a class prvalue** is allowed since C++17 and yields an **xvalue** (materialized temporary).

**Lifetime notes**
- A **scalar prvalue** (e.g., `a + b`) has no identity; when used to initialize a variable, that value is **copied/moved into the target**.
- A **class prvalue** denotes a **result object**; upon materialization (e.g., binding to `const T&`), a **temporary** is created and destroyed at the **end of the full-expression** (lifetime can be **extended** by binding to a `const T&` or `T&&` in certain cases).

## **2. Common Expressions**

| Expression | Type (ex.) | Category | Notes| 
| :--------: | :--------: | :------: | ---- |
| `x`, `*p`, `a[i]`, `obj.m`                | as declared          | **lvalue**  | Has identity; `&x` OK.                                  |
| `"hello"`                                 | `const char[N]`      | **lvalue**  | String literal is an array lvalue.                      |
| Function name `f`                         | function type        | **lvalue**  | Function designators are lvalues.                       |
| `std::move(x)` <br> `static_cast<T&&>(x)` | `T&&`                | **xvalue**  | Move-eligible glvalue.                                  |
| Call returning `T&&`                      | `T&&`                | **xvalue**  | Rvalue-ref result.                                      |
| `42`, `3.14`, `a+b`, <br> `T{...}`, `f()`    | `int`, `double`, `T` | **prvalue** | Class/array prvalues denote **result objects** (C++17). |
| `static_cast<T&>(e)`                      | `T&`                 | **lvalue**  | Cast to lvalue ref.                                     |
| `static_cast<void>(e)` <br> `throw e`         | `void`               | **prvalue** | Discarded-value contexts.                               |
| `a.mf` / `p->mf` <br> (non-static mem-func)    | function type        | **prvalue** | Only as left operand of `()` call.                      |

---

## **3. Quick Decision Guide**
1. **Identity?**
  - Yes &rarr; it’s a **glvalue** (either lvalue or xvalue) &rarr; go to (2).
  - No &rarr; **prvalue**.

2. **Move-eligible?** *(would it bind to `T&&`?)*
  - Yes &rarr; **xvalue**.
  - No &rarr; **lvalue**.

3. **Member access:** follows the base expression’s category.
  - lvalue base &rarr; **lvalue** member (`obj.m`)
  - xvalue or class prvalue base &rarr; **xvalue** member (`std::move(obj).m`, `S{}.m`)

4. **Inc/dec:** 
  - `++x/--x` &rarr; **lvalue**. 
  - `x++/x--` &rarr; **prvalue**.

5. **Address-of:** built-in `&` applies only to **lvalues** (and functions).

6. **Overload binding:**
  - `T&` &larr; lvalue
  - `const T&` &larr; lvalue **or** rvalue
  - `T&&` &larr; rvalue (prvalue/xvalue)

---

## **4. Reference Binding Cheat Sheet**

| Target parameter                    | Binds to lvalue | Binds to prvalue/xvalue | Notes                                         |
| :---------------------------------: | :-------------: | :---------------------: | --------------------------------------------- |
| `T&`                                |        O        |            X            | For modifiable lvalues only                   |
| `const T&`                          |        O        |            O            | Materializes temporaries; extends lifetime    |
| `T&&`                               |        X        |            O            | Consuming/move sinks                          |
| `T&&` <br> (forwarding ref in templates) |     O      |            O            | Use `std::forward<T>(t)` to preserve category |

> Tip: To classify an expression at compile time, use `decltype((expr))`:   
> lvalue &rarr; `T&`, xvalue &rarr; `T&&`, prvalue &rarr; `T` (non-reference).

---

## **5. Materialization & Elision (C++17+)**
  - **Temporary materialization**
    - when a **class/array prvalue** appears where a **glvalue** is required (e.g., reference binding, member access), the implementation **materializes a temporary** and the resulting expression is an **xvalue** designating that temporary.
    - Examples: `S{}.m`, `const S& r = S{};`
  - **Lifetime extension:** if a temporary binds to `const T&` or `T&&`, its lifetime is extended appropriately.
  - **Mandatory copy elision:** in many cases (e.g., `T x = T{};`, `return T{...};`, `throw T{...};`) the object is **constructed directly in place** with no separate temporary.

---

## **6. Examples**

```cpp
#include <string>
#include <utility>
struct S { int m = 1; void touch() & {} void touch() && {} };

S s;                         // 's' expression: lvalue
(std::move(s)).touch();      // rvalue base -> calls &&-qualified member
auto t = S{};                // constructed directly from a prvalue (elision)
static_assert(std::is_rvalue_reference_v<decltype((S{}.m))>); // member access: xvalue
```

---

```cpp
int x = 0;
static_assert( std::is_lvalue_reference_v<decltype((x))> );            // lvalue
static_assert(!std::is_lvalue_reference_v<decltype((x++))>);           // prvalue
static_assert( std::is_rvalue_reference_v<decltype((std::move(x)))> ); // xvalue
```

---

## **7. Pitfalls**
- **Rvalue-ref variable name is an lvalue:** `int&& rr=0; rr` is an lvalue—use `std::move(rr)` to pass as rvalue.
- **Built-in `&` on rvalues:** `&std::move(x)` and `&(a+b)` are ill-formed.
- **Temporary lifetime mistakes:** `const T& r = T{};` extends lifetime; views/subobjects may not.
- **Overusing `std::move`:** can block copy elision (`return x;` is often best post-C++17).
- **Bit-fields:** address cannot be taken; non-const lvalue refs cannot bind.
- **Member function designator misuse:** `obj.mf` (the designator) is only for calling.

---

## **8. Since / Changed in**
- **C++17**: prvalues denote **result objects**; **temporary materialization** (prvalue→xvalue); wider **mandatory copy elision**.
- **C++23**: clarifications: certain move-eligible expressions (e.g., some `return`/`co_return`/`throw` sites) are treated as **rvalues** for overload resolution.

---

## **9. See also**
- Value categories
- Implicit conversions (temporary materialization)
- Reference initialization
- Order of evaluation.

## **10. References**
- [cppreference.com - std::is_rvalue_reference](https://en.cppreference.com/w/cpp/types/is_rvalue_reference.html)
- [cppreference.com - std::is_lvalue_reference](https://en.cppreference.com/w/cpp/types/is_lvalue_reference.html)
- [devdocs.io - Value caetgories](https://devdocs.io/cpp/language/value_category)
- [C++ Values(lvalue, rvalue, xvalue, prvalue, glvalue)](https://dydtjr1128.github.io/cpp/2019/06/10/Cpp-values.html)