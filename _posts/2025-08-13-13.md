---
title: "[C/C++] Memory: std::aligned_alloc"
author: zerogod
date: 2025-08-13 12:30 +0900
categories: [C/C++, Memory]
tags: [C/C++, memory, alloc]
render_with_liquid: true
---
## ***Define***
`aligned_alloc` is defined in header `<cstdlib>` since C++17.   

```cpp
void* aligned_alloc(std::size_t alignment, std::size_t size);
```
- Allocate `size` bytes of uninitialized storage whose alignment is specified by `alignment` (implicitly creating objects in the destination area).  
- The `size` parameter must be an **integral multiple** of `alignment`.


## ***Parameters***

| Parameter | Description |
| :----------: | -------- |
| `alignment` | Specifies the alignment. Must be a valid alignment supported by the implementation. |
| `size` | Number of bytes to allocate. An integral multiple of `alignment`. |


## ***Return Value***
On success, returns the pointer to the beginning of newly allocated memory. To avoid a memory leak, the returned pointer must be deallocated with `std::free` or `std::realloc`.

On failure, returns a null pointer.

## ***Notes***
- **Size requirement** &mdash; If `size` is not an integral multiple of `alignment`, the function returns `nullptr` (DR460).

- **Alignment restriction** &mdash; The `alignment` must be supported by the implementation.   
  Many POSIX implementations require it to be a power of two and a multiple of `sizeof(void*)` (same as `posix_memalign`).   
  Fundamental alignments are always supported: if `alignment` is a power of two and not greater than `alignof(std::max_align_t)`, `aligned_alloc` may simply call `std::malloc`.

- **Windows** &mdash; MSVC's runtime library does not support `std::aligned_alloc`. Use `_aligned_malloc` / `_aligned_free` instead.

- **Object creation** â€” `aligned_alloc` only allocates raw memory. For class/array types, you must explicitly construct objects (e.g., placement `new`).


## ***Example***

{% code_runner id="1" language="cpp" filename="aligned_alloc" %}
#include <cstdio>
#include <cstdlib>
#include <cstdint>
#include <inttypes.h>
 
int main()
{
    // default-aligned malloc
    int *p1 = static_cast<int *>(std::malloc(10 * sizeof *p1));
    printf("default-aligned address:   %p\n", static_cast<void *>(p1));
    printf("p1 %% 1024 = %" PRIuPTR "\n", (uintptr_t)p1 % 1024u);
    std::free(p1);

    // 1024-byte aligned (size must be multiple of alignment)
    int *p2 = static_cast<int *>(std::aligned_alloc(1024, 1024));
    printf("1024-byte aligned address: %p\n", static_cast<void*>(p2));
    printf("p2 %% 1024 = %" PRIuPTR "\n", (uintptr_t)p2 % 1024u);
    std::free(p2);
}
{% endcode_runner %}

## ***References***
1. [C++ documentation](https://devdocs.io/cpp/memory/c/aligned_alloc)