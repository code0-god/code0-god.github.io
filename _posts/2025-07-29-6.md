---
title: "[C/C++] User-defined Macro(2): Advanced"
author: zerogod
date: 2025-07-29 06:38 +0900
categories: [C/C++, Language, Preprocessor]
tags: [C/C++, macro, preprocessor, "#define", conditional-compilation]
render_with_liquid: true
---
## ***Abstract***  
This post explores advanced macro techniques in C and C++, including stringification (`#`), token pasting (`##`), conditional compilation directives, variadic macros, and predefined debugging macros.

## ***1. Introduction***  
Beyond simple constants and function-like macros, the C preprocessor provides powerful metaprogramming features.   
Stringification and token pasting enable dynamic identifier and string creation; conditional directives (`#ifdef`, `#ifndef`, `#undef`) control compilation flow; variadic macros support flexible argument lists; and predefined macros (`__FILE__`, `__LINE__`, `__func__`) aid in debugging and diagnostics.

## ***2. Organization***  
1. **Token Pasting and Stringification** &mdash; `#` and `##` operators  
2. **Conditional Compilation** &mdash; `#ifdef`, `#ifndef`, `#undef`  
3. **Variadic Macros** &mdash; `__VA_ARGS__` and comma-swallowing  
4. **Predefined Debugging Macros** &mdash; `__FILE__`, `__LINE__`, `__func__`  
5. **Previous** &mdash; Link to the basic macro features post

---
## ***3. Sections***
### ***3.1. Stringification and Token Pasting***
The `#` operator converts an argument into a string constant as shown below:

{% code_runner id="1" language="cpp" filename="macro5" %}
#define TO_STRING(x) #x
#include <cstdio>

int main() {
    printf("%s\n", TO_STRING(This is a string constant.));

    return 0;
}
{% endcode_runner %}

Simillarly, `##` operator pastes token to one identifier.

{% code_runner id="2" language="cpp" filename="macro6" %}
#define MAKE_VAR(x) var_##x
#include <cstdio>
int main() {
    int var_1 = 1, var_2 = 2;
    printf("var_1 + var_2 = %d\n", MAKE_VAR(1) + MAKE_VAR(2));    

    return 0;
}
{% endcode_runner %}

### ***3.2. Conditional Compilation***
Macros can also be used for conditional branching using preprocessor directives.

The `#ifndef` directive means: 
> "if this *identifier* has not been  defined."

This allows you to define a macro only if it hasn't been defined elsewhere--useful to ensuring consistent values across multiple files.
```cpp
#ifndef PI
#define PI 3.141592
#endif
```
Simillarly, the `#ifdef` directive means: 
> "if this *identifier* has been defined."

```cpp
#define DEBUG

#ifdef DEBUG
    printf("Debug mode is on.\n");
#endif
```

To undefine a macro, use the `#undef` directive:
> **#undef** *identifier*.   

### ***3.3. Variadic Macros***
Variadic macros are function-like macros that accept a **variable number of arguments.**

{% code_runner id="3" language="cpp" filename="macro7" %}
#define PRINT(...) printf(__VA_ARGS__)
#include <cstdio>

int main() {
    PRINT("Hello, %s!\n", "World");

    return 0;
};
{% endcode_runner %}

The `...`(ellipsis) is replaced by the special identifier `__VA_ARGS__`, which gets expanded into the variable arguments passed to the macro.

`__VA_ARGS__` is especially useful for writing flexible debugging macros:

{% code_runner id="4" language="cpp" filename="macro8" %}
// '\' is wrapping
#define DBG(caller, fmt, ...) \ 
            fprintf(stderr, "[%s] " fmt, caller, __VA_ARGS__)
#include <cstdio>

int main() {
    int row_stride = 16;
    DBG("Gemmini", "row_stride: %d\n", row_stride);
    
    return 0;
}
{% endcode_runner %}

However, this version will cause a compile error if no arguments are passed for `__VA_ARGS__` as below shown:

{% code_runner id="5" language="cpp" filename="macro9" %}
// '\' is wrapping
#define DBG(caller, fmt, ...) \ 
            fprintf(stderr, "[%s] " fmt, caller, __VA_ARGS__)
#include <cstdio>

int main() {
    DBG("Gemmini", "matmul called.\n");
    
    return 0;
}
{% endcode_runner %}

To fix it, use `##__VA_ARGS__` instead, which removes the preceding comma if no arguments follow:

{% code_runner id="6" language="cpp" filename="macro10" %}
#define DBG(caller, fmt, ...) \
            fprintf(stderr, "[%s] " fmt, caller, ##__VA_ARGS__)
#include <cstdio>

int main() {
    int row_stride = 16;
    // fprintf(stderr, "[%s] " "matmul called.\n", "Gemmini")
    DBG("Gemmini", "matmul called.\n");
    
    return 0;
}
{% endcode_runner %}

In this example, `##__VA_ARGS__` ensures that the comma is safely removed if __VA_ARGS__ is empty.


### ***3.4. Predefined Debugging Macros***
You can also use standard predefined macros to show contextual information like the file name, line number, or function name:
- `__FILE__`: Expands to the current file name
- `__LINE__`: Expands to the current line number
- `__func__`: Expands to the name of the current function

{% code_runner id="7" language="cpp" filename="macro11" %}
#define DBG(fmt, ...) \
    fprintf(stderr, "[%s:%d] %s(): " fmt"\n", __FILE__, __LINE__, __func__, ##__VA_ARGS__)
#include <cstdio>

int main() {
    int val = 10;
    // fprintf(stderr, "[%s:%d] %s(): " "value = %d", val"\n", __FILE__, __LINE__, __func__, val);
    DBG("value = %d", val);

    return 0;
}
{% endcode_runner %}

This is particularly useful for tracing execution or reporting errors during development.

### ***3.5. Previous***
> Previous: [User-defined Macro(1): Basics](https://code0-god.github.io/posts/5/)