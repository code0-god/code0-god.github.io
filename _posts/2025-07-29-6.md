---
title: "[C/C++] User-defined Macro(2): Advanced"
author: zerogod
date: 2025-07-29 06:38 +0900
categories: [C/C++, Macro]
tags: [C/C++, macro]
render_with_liquid: false
---
## ***Abstract***  
This post explores advanced macro techniques in C and C++, including stringification (`#`), token pasting (`##`), conditional compilation directives, variadic macros, and predefined debugging macros.

## ***1. Introduction***  
Beyond simple constants and function-like macros, the C preprocessor provides powerful metaprogramming features.   
Stringification and token pasting enable dynamic identifier and string creation; conditional directives (`#ifdef`, `#ifndef`, `#undef`) control compilation flow; variadic macros support flexible argument lists; and predefined macros (`__FILE__`, `__LINE__`, `__func__`) aid in debugging and diagnostics.

## ***2. Organization***  
1. **Token Pasting and Stringification** &mdash; `#` and `##` operators  
2. **Conditional Compilation** &mdash; `#ifdef`, `#ifndef`, `#undef`  
3. **Variadic Macros** &mdash; `__VA_ARGS__` and comma-swallowing  
4. **Predefined Debugging Macros** &mdash; `__FILE__`, `__LINE__`, `__func__`  
5. **Previous** &mdash; Link to the basic macro features post

---
## ***3. Sections***
### ***3.1. Stringification and Token Pasting***
The `#` operator converts an argument into a string constant as shown below:
```cpp
#define TO_STRING(x) #x
#include <cstdio>

int main() {
    printf("%s\n", TO_STRING(This is a string constant.));

    return 0;
}
```
```bash
This is a string constant
```   

Simillarly, `##` operator pastes token to one identifier.
```cpp
#define MAKE_VAR(x) var_##x
#include <cstdio>
int main() {
    int var_1 = 1, var_2 = 2;
    printf("var_1 + var_2 = %d\n", MAKE_VAR(1) + MAKE_VAR(2));    

    return 0;
}
```
```bash
var_1 + var_2 = 3
```

### ***3.2. Conditional Compilation***
Macros can also be used for conditional branching using preprocessor directives.

The `#ifndef` directive means: 
> "if this *identifier* has not been  defined."

This allows you to define a macro only if it hasn't been defined elsewhere--useful to ensuring consistent values across multiple files.
```cpp
#ifndef PI
#define PI 3.141592
#endif
```
Simillarly, the `#ifdef` directive means: 
> "if this *identifier* has been defined."

```cpp
#define DEBUG

#ifdef DEBUG
    printf("Debug mode is on.\n");
#endif
```

To undefine a macro, use the `#undef` directive:
> **#undef** *identifier*.   

### ***3.3. Variadic Macros***
Variadic macros are function-like macros that accept a **variable number of arguments.**
```cpp
#define PRINT(...) printf(__VA_ARGS__)
#include <cstdio>

int main() {
    PRINT("Hello, %s!\n", "World");

    return 0;
}; 
```
```bash
Hello, World!
```
The `...`(ellipsis) is replaced by the special identifier `__VA_ARGS__`, which gets expanded into the variable arguments passed to the macro.

`__VA_ARGS__` is especially useful for writing flexible debugging macros:
```cpp
#define DBG(caller, fmt, ...) \ // '\' is wrapping
            fprintf(stderr, "[%s] " fmt, caller, __VA_ARGS__)
#include <cstdio>

int main() {
    int row_stride = 16;
    DBG("Gemmini", "row_stride: %d\n", row_stride);
    
    return 0;
}
```
```bash
[Gemmini] row_stride: 16
```
However, this version will cause a compile error if no arguments are passed for `__VA_ARGS__` as below shown:
```cpp
DBG("Gemmini", "matmul called.\n");
```
```bash
g++ -o macro macro.cpp
macro7.cpp: In function ‘int main()’:
macro7.cpp:1:79: error: expected primary-expression before ‘)’ token
    1 | #define DBG(caller, fmt, ...) fprintf(stderr, "[%s] " fmt, caller, __VA_ARGS__)
      |                                                                               ^
macro7.cpp:6:5: note: in expansion of macro ‘DBG’
    6 |     DBG("Gemmini", "mulmat called.\n");
      |     ^~~
```

To fix it, use `##__VA_ARGS__` instead, which removes the preceding comma if no arguments follow:
```cpp
#define DBG(caller, fmt, ...) \
            fprintf(stderr, "[%s] " fmt, caller, ##__VA_ARGS__)
#include <cstdio>

int main() {
    int row_stride = 16;
    // fprintf(stderr, "[%s] " "matmul called.\n", "Gemmini")
    DBG("Gemmini", "matmul called.\n");
    
    return 0;
}
```
```bash
[Gemmini] matmul called.
```
In this example, `##__VA_ARGS__` ensures that the comma is safely removed if __VA_ARGS__ is empty.


### ***3.4. Predefined Debugging Macros***
You can also use standard predefined macros to show contextual information like the file name, line number, or function name:
- `__FILE__`: Expands to the current file name
- `__LINE__`: Expands to the current line number
- `__func__`: Expands to the name of the current function

```cpp
#define DBG(fmt, ...) \
    fprintf(stderr, "[%s:%d] %s(): " fmt"\n", __FILE__, __LINE__, __func__, ##__VA_ARGS__)
#include <cstdio>

int main() {
    int val = 10;
    // fprintf(stderr, "[%s:%d] %s(): " "value = %d", val"\n", __FILE__, __LINE__, __func__, val);
    DBG("value = %d", val);

    return 0;
}
```
```bash
[debug.cpp:8] main(): value = 10
```
This is particularly useful for tracing execution or reporting errors during development.

### ***3.5. Previous***
> Previous: [User-defined Macro(1): Basics](https://code0-god.github.io/posts/5/)