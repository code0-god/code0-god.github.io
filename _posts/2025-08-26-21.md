---
title: "[C++] Class: Basic Syntax"
author: zerogod
date: 2025-08-26 23:25 +0900
categories: [C/C++, Language, Classes]
tags: [C++, class, basic, syntax, declaration]
render_with_liquid: true
use_math: true
---

## **Abstract**
As a core **User-Defined Type (UDT)** in C++, the `class` is fundamental for **object-oriented programming**. It encapsulates data and behavior, separating the public **interface** from the private **implementation**[^1], while managing resource lifetime through **constructors** and **destructors** (**RAII**).

This article provides a practical guide to the essential syntax, covering `class` declaration, access control (`class` vs. `struct`), member initialization, **const-correctness**, and the role of **constructors** and **destructors** in **object lifecycle management**.

> The central language feature of C++ is the `class`.[^2]

## **Introduction**
This article aims to equip readers with the ability to use C++ `classes` effectively, focusing on the minimal syntax required without compromising safety or established idioms.

The guiding principle is to distinguish between the **interface** to a type (to be used by all) and its **implementation** (which has access to the otherwise inaccessible data)[^1]. Hiding internal **implementation** details is a cornerstone of robust **object-oriented design**.

## **Organizations**
1. Class at a Glance
2. class vs. struct (Basics)
3. The Simplest Class: Declaration and Members
4. Ensuring Initialization with Constructors
5. Member Functions and const-correctness
6. A More Practical Example: The Buffer Class
7. Managing Resources with Destructors and RAII
8. Preview of the Next Article (Advanced Topics)

---

## **1. Class at a Glance**
- **Definition**: A `class` is a **user-defined type** provided to represent an entity in the code of a program.[^3]
- **Core Philosophy**: Whenever our design for a program has a useful idea, entity, etc., we try to represent it as a `class` in the program so that the idea is there in the code, rather than just in our heads, in a design document, or in some comments.[^4]
- **Concrete Type**: The defining characteristic of a **concrete type** is that its **representation** is part of its definition.[^5]

## **2. class vs. struct (Basics)**
- **`class` and `struct`**
  - There is no fundamental difference between a `struct` and a `class`; a `struct` is simply a `class` with members `public` by default.[^6]

## **3. The Simplest Class: Declaration and Members**
A class bundles data and behavior. The **interface** of a `class` is defined by its `public` members, and its `private` members are accessible only through that **interface**.[^7]

Here is a simple class declaration:
```cpp
class SimpleValue {
public:
    void set(int v) { value_ = v; } // Public member function (setter)
    int get() { return value_; }      // Public member function (getter)

private:
    int value_; // Private data member
};
```
- **Key Points**
  - We define a new type named `SimpleValue`.
  - It has a `private` data member `value_` to hold an integer.
  - It provides a `public` **interface** with two member functions, `set()` and `get()`, to interact with the data.
  - Conventionally, we place the `public` declarations first and the `private` declarations later.[^8]

## **4. Ensuring Initialization with Constructors**
A member function with the same name as its class is called a **constructor**. Unlike an ordinary function, a **constructor** is guaranteed to be used to initialize objects of its class. Thus, defining a **constructor** eliminates the problem of **uninitialized variables** for a `class`.[^9]

We can improve `SimpleValue` by adding a constructor to ensure it always holds a valid value upon creation.
```cpp
class SimpleValue {
public:
    // Constructor with member initializer list
    SimpleValue(int v) : value_{v} {}

    void set(int v) { value_ = v; }
    int get() { return value_; }

private:
    int value_;
};
```
- **Member Initializer List**: Members should be initialized in the constructor's header using a **member initializer list** (e.g., `: value_{v}`) rather than by assignment in the constructor's body. This is more efficient and often necessary for `const` or reference members.

## **5. Member Functions and const-correctness**
- **Member Functions**: Functions defined in a `class` are **inlined** by default.[^10]
- **`const` Member Functions**: A `const` **member function** can be invoked for both `const` and `non-const` objects, but a non-`const` **member function** can only be invoked for `non-const` objects.[^11]

The `get()` function in our `SimpleValue` class doesn't (and shouldn't) modify the object's state. We can and should mark it as `const`.
```cpp
class SimpleValue {
public:
    SimpleValue(int v) : value_{v} {}

    void set(int v) { value_ = v; }
    int get() const { return value_; } // This function does not modify the object

private:
    int value_;
};
```
Marking getters as `const` is a fundamental part of writing correct and robust C++ code.

## **6. A More Practical Example: The Buffer Class**
Now that we understand the basics, let's look at a more realistic example that combines these concepts.
```cpp
#include <vector>

class Buffer {
public:
  // 1) explicit constructor to prevent implicit conversions
  explicit Buffer(int n) : data_(n, 0) {}

  // 2) const member function for read-only access
  int size() const { return static_cast<int>(data_.size()); }

  // 3) const-overloading for flexible access
  int&       at(int i)       { return data_.at(i); } // For non-const objects
  const int& at(int i) const { return data_.at(i); } // For const objects

private:
  std::vector<int> data_;
};
```
- **`explicit` Constructors**: The `explicit` keyword prevents the compiler from using a constructor for implicit type conversions, which can help avoid surprising behavior.
- **`const`-Overloading**: Providing two versions of `at()`—one `const` and one not—is a common C++ idiom. It allows `const` objects to get read-only access while non-`const` objects can get read-write access.
- **Handles**: A common technique for handling varying amounts of information is to use a fixed-size **handle** (like the `std::vector` member `data_`) referring to a variable amount of data "elsewhere"[^12].

## **7. Managing Resources with Destructors and RAII**
- **Destructor**: The complement to a **constructor** is a **destructor**. The name of a **destructor** is the `~` character followed by the name of the `class`; it is the complement of a **constructor**.[^13]
- **RAII**: The technique of acquiring resources in a **constructor** and releasing them in a **destructor**, known as **Resource Acquisition Is Initialization** or **RAII**, is the basis for most C++ resource management techniques.[^14]

This is most clearly seen when managing raw resources like file handles or memory.
```cpp
#include <cstdio>

class FileGuard {
public:
  explicit FileGuard(std::FILE* f) : f_(f) {}
  ~FileGuard() { if (f_) std::fclose(f_); }  // Resource released in destructor (RAII)

  std::FILE* get() const { return f_; }
private:
  std::FILE* f_{};
};
```
When a `FileGuard` object goes out of scope, its destructor is automatically called, ensuring the file is closed.

## **8. Preview of the Next Article (Advanced Topics)**
- **Operator Overloading** (member/non-member, symmetric operation idioms)
- **Copy/Move**, `=default`/`=delete`, **Rule of 0/3/5**
- **Inheritance**, **Virtual Destructors**, **Polymorphism**, **Interface Segregation**
- `explicit`, **Conversion Constructors**, **Delegating/Inheriting Constructors**, `friend`

---

## **References**

[^1]: Bjarne Stroustrup, A Tour of C++ (3rd ed.), p. 23. "...distinguish between the interface to a type (to be used by all) and its implementation (which has access to the otherwise inaccessible data)."

[^2]: Bjarne Stroustrup, A Tour of C++ (3rd ed.), p. 54. "The central language feature of C++ is the class."

[^3]: Bjarne Stroustrup, A Tour of C++ (3rd ed.), p. 54. "A class is a user-defined type provided to represent an entity in the code of a program."

[^4]: Bjarne Stroustrup, A Tour of C++ (3rd ed.), p. 54. "Whenever our design for a program has a useful idea, entity, collection of data, etc., we try to represent it as a class in the program so that the idea is there in the code, rather than just in our heads, in a design document, or in some comments."

[^5]: Bjarne Stroustrup, A Tour of C++ (3rd ed.), p. 54. "The defining characteristic of a concrete type is that its representation is part of its definition."

[^6]: Bjarne Stroustrup, A Tour of C++ (3rd ed.), p. 25. "There is no fundamental difference between a struct and a class; a struct is simply a class with members public by default."

[^7]: Bjarne Stroustrup, A Tour of C++ (3rd ed.), p. 23. "The interface of a class is defined by its public members, and its private members are accessible only through that interface."

[^8]: Bjarne Stroustrup, A Tour of C++ (3rd ed.), p. 23. "...conventionally we place the public declarations first and the private declarations later..."

[^9]: Bjarne Stroustrup, A Tour of C++ (3rd ed.), p. 24. "A member function with the same name as its class is called a constructor... Unlike an ordinary function, a constructor is guaranteed to be used to initialize objects of its class. Thus, defining a constructor eliminates the problem of uninitialized variables for a class."

[^10]: Bjarne Stroustrup, A Tour of C++ (3rd ed.), p. 56. "Functions defined in a class are inlined by default."

[^11]: Bjarne Stroustrup, A Tour of C++ (3rd ed.), p. 56. "A const member function can be invoked for both const and non-const objects, but a non-const member function can only be invoked for non-const objects."

[^12]: Bjarne Stroustrup, A Tour of C++ (3rd ed.), p. 24. "This is the basic technique for handling varying amounts of information in C++: a fixed-size handle referring to a variable amount of data 'elsewhere'..."

[^13]: Bjarne Stroustrup, A Tour of C++ (3rd ed.), p. 57. "The name of a destructor is the complement operator, ~, followed by the name of the class; it is the complement of a constructor."

[^14]: Bjarne Stroustrup, A Tour of C++ (3rd ed.), p. 58. "The technique of acquiring resources in a constructor and releasing them in a destructor, known as Resource Acquisition Is Initialization or RAII."
