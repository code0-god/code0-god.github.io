---
title: "[C/C++] Fundamental Type: int"
author: zerogod
date: 2025-08-01 10:04 +0900
categories: [C/C++, Types, Fundamental]
tags: [C/C++, type, int]
render_with_liquid: false
use_math: true
---

## ***Abstract***  
This post provides an in-depth overview of the fundamental C/C++ integer type `int`, covering its definition, typical size, value range, signed vs. unsigned variants, and practical usage guidelines.

## ***1. Introduction***  
In C and C++, `int` is the default integer type used for counting, indexing, and arithmetic. Although the standard guarantees only a minimum range, the actual size and representation of `int` vary across platforms. Understanding these platform-dependent characteristics is essential for writing portable and correct code.

## ***2. Organization***  
1. **Definition & Representation** — What the C/C++ standard specifies about `int`.  
2. **Size & Range** — Typical widths, minimum requirements, and value limits.  
3. **Signed vs. Unsigned** — Behavior differences and when to use each.  
4. **Usage Guidelines & Pitfalls** — Best practices and common mistakes.

---

## ***3. Sections***

### ***3.1. Definition & Representation***  
- **Standard definition**: `int` is a signed integer type capable of representing at least the range −32,767 to 32,767.  
- **Typical representation**: Two’s-complement on almost all modern architectures.  
- **Underlying bits**: Exactly `CHAR_BIT * sizeof(int)` bits (where `CHAR_BIT` $\ge$ 8).

```cpp
#include <cstdio>
#include <climits>

int main() {
    printf("Size of int: %zu bytes\n", sizeof(int));
    printf("INT_MIN: %d, INT_MAX: %d\n", INT_MIN, INT_MAX);
    return 0;
}
```
```shell
Size of int: 4 bytes
INT_MIN: -2147483648, INT_MAX: 2147483647
```

### ***3.2. Size & Range***  
- **Minimum requirements** (C99/C++11):  
  - `sizeof(int)` $\ge$ 2 bytes  
  - `INT_MIN` $\le$ −32767, `INT_MAX` $\ge$ 32767  
- **Common implementations**:  
  - 32-bit systems: `sizeof(int) == 4`, range $\approx$ $2^{15}$ to $2^{15}-1$  
  - 64-bit systems: often the same as above for LP64 models  
- **Macros**: Defined in `<climits>` / `<limits.h>`: `INT_MIN`, `INT_MAX`

```cpp
#include <stdio.h>
#include <climits>

void main(void) {
    printf("int is %zu bytes, range [%d .. %d]\n",
           sizeof(int), INT_MIN, INT_MAX);
}
```
### ***3.3. Signed vs. Unsigned int***  
- **Signed `int`**: Range includes negative values (`INT_MIN` … `INT_MAX`).  
- **Unsigned `int`**: Range 0 … `UINT_MAX` (`2ⁿ − 1`).  
- **Conversions & promotions**: Mixed signed/unsigned expressions can lead to unexpected results due to integer promotions.

```cpp
#include <cstdio>

int main() {
    int a = -5;
    unsigned int b = 3;
    // a + b: 'a' is converted to unsigned, causing very large result
    printf("a + b = %u\n", a + b);
    return 0;
}
```
```shell
a + b = 4294967294
```

### ***코드 에디터 & 실행 결과***

  <style>
    /* wrapper를 기준으로 overlay 위치 계산 */
    #wrapper {
      position: relative;
      width: 100%;
      margin: auto;
    }

    /* iframe은 pointer-events:none 으로 편집 비활성화 */
    #oc-editor {
      width: 100%;
      height: 240px;
      border: none;
      pointer-events: none;
    }

    /* 투명 오버레이 버튼 */
    #fake-run {
      position: absolute;
      background: transparent;
      border: none;
      cursor: pointer;
      z-index: 10;
      /* top/left/width/height 는 JS에서 계산 */
    }

    /* 콘솔 */
    #console {
      background: #111;
      color: #0f0;
      padding: 1em;
      min-height: 120px;
      white-space: pre-wrap;
      overflow-y: auto;
      border: 1px solid #444;
      margin-top: .5em;
    }
    /* 숨겨진 포커스 홀더 */
    #focus-holder {
      position: absolute;
      width: 0;
      height: 0;
      overflow: hidden;
      outline: none;
    }
  </style>
<body>
  <div id="focus-holder" tabindex="-1"></div>
  <div id="wrapper">
    <!-- 1) 읽기 전용 에디터 (OneCompiler iFrame) -->
    <iframe
      id="oc-editor"
      src="https://onecompiler.com/embed/cpp?listenToEvents=true&hideLanguageSelection=true&hideNew=true&hideNewFileOption=true&hideTitle=true&hideEditorOptions=true&hideStdin=true&hideResult=true&theme=dark&codeChangeEvent=true">
    </iframe>

    <!-- iframe 우상단 Run ▶ 위치에 덮을 투명 버튼 -->
    <button id="fake-run" aria-label="Run"></button>
  </div>

  <!-- 4) 콘솔 -->
  <pre id="console">No output</pre>

  <script>
    // 고정 C++ 코드
    const FIXED_CODE = `
#include <cstdio>

int main() {
    int a = -5, b = 3;
    printf("a + b = %u\\n", a + b);
    return 0;
}

`;

    // 1) 실행 로직
    async function runCode() {
      const out = document.getElementById('console');
      out.textContent = 'Running…';

      try {
        const resp = await fetch(
          'https://onecompiler-apis.p.rapidapi.com/api/v1/run', {
            method: 'POST',
            headers: {
              'Content-Type':   'application/json',
              'X-RapidAPI-Key': '7876acb14emshbef1e44fdc99122p110b48jsn9f388c2d805a',
              'X-RapidAPI-Host':'onecompiler-apis.p.rapidapi.com'
            },
            body: JSON.stringify({
              language: 'cpp',
              version:  'latest',
              files: [{ name:'main.cpp', content: FIXED_CODE }]
            })
          }
        );
        const j = await resp.json();
        out.textContent = j.stdout || j.output || j.errors || j.stderr || 'No output';
      } catch (e) {
        out.textContent = 'Error: ' + e.message;
      }
    }

    // 2) 외부 버튼 클릭 바인딩
    document.getElementById('fake-run').addEventListener('click', runCode);

    // iframe 로드 완료 시점에 코드 주입
    document.getElementById('oc-editor').addEventListener('load', () => {
      const iframeWin = document.getElementById('oc-editor').contentWindow;
      // 1) 코드 주입
      iframeWin.postMessage({
        eventType: 'populateCode',
        language: 'cpp',
        files: [{ name:'main.cpp', content: FIXED_CODE.trimgStart() }]
      }, '*');
      // 2) 바로 포커스 해제
      setTimeout(() => {
        document.getElementById('oc-editor').blur();
        document.getElementById('focus-holder').focus();
        window.focus();
      }, 50);
    });

    // 5) overlay 위치/크기 계산 함수
    function updateOverlay() {
      const iframe  = document.getElementById('oc-editor');
      const overlay = document.getElementById('fake-run');
      const wrap    = document.getElementById('wrapper');

      const ifrRect = iframe.getBoundingClientRect();
      const wpRect  = wrap.getBoundingClientRect();

      // iframe 내부 우상단에 Run 버튼이 위치한다고 가정
      const btnW = 80;   // Run ▶ 버튼 예상 너비
      const btnH = 32;   // Run ▶ 버튼 예상 높이
      const padX = 16;   // 오른쪽 여백
      const padY = 16;   // 상단 여백

      // wrapper 기준 상대 좌표
      const top  = ifrRect.top  - wpRect.top + padY;
      const left = ifrRect.left - wpRect.left + (iframe.clientWidth - btnW - padX);

      overlay.style.width  = btnW + 'px';
      overlay.style.height = btnH + 'px';
      overlay.style.top    = top  + 'px';
      overlay.style.left   = left + 'px';
    }

    // 6) 초기/리사이즈 시 오버레이 업데이트
    window.addEventListener('load',   updateOverlay);
    window.addEventListener('resize', updateOverlay);
  </script>
</body>



### ***3.4. Usage Guidelines & Pitfalls***  
- **Use `int` for general-purpose loops and counters** unless a specific range or performance concern dictates otherwise.  
- **Avoid assumptions** about byte size; rely on `sizeof(int)` and `INT_MAX`/`UINT_MAX`.  
- **Beware of overflow**: Signed overflow is undefined; unsigned overflow wraps around.  
- **Prefer `unsigned` only when non-negative values are guaranteed** and wrapping behavior is desirable.  
- **When interfacing with APIs or file formats**, match the expected width explicitly (e.g., use `int32_t` if 32-bit is required).

```cpp
// Example: prefer unsigned only when safe
for (unsigned int i = 0; i < array_length; i++) {
    // ...
}
```
---

This focused analysis of the `int` type lays the groundwork for subsequent posts on other fundamental and fixed-width integer types.
