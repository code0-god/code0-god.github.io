---
title: "[C/C++] Fundamental Type: int"
author: zerogod
date: 2025-08-01 10:04 +0900
categories: [C/C++, Types, Fundamental]
tags: [C/C++, type, int, width, range, signedness]
render_with_liquid: true
use_math: true
---

## ***Abstract***  
This post provides an in-depth overview of the fundamental C/C++ integer type `int`, covering its definition, typical size, value range, signed vs. unsigned variants, and practical usage guidelines.

## ***1. Introduction***  
In C and C++, `int` is the default integer type used for counting, indexing, and arithmetic. Although the standard guarantees only a minimum range, the actual size and representation of `int` vary across platforms. Understanding these platform-dependent characteristics is essential for writing portable and correct code.

## ***2. Organization***  
1. **Definition & Representation** — What the C/C++ standard specifies about `int`.  
2. **Size & Range** — Typical widths, minimum requirements, and value limits.  
3. **Signed vs. Unsigned** — Behavior differences and when to use each.  
4. **Usage Guidelines & Pitfalls** — Best practices and common mistakes.

---

## ***3. Sections***

### ***3.1. Definition & Representation***  
- **Standard definition**: `int` is a signed integer type capable of representing at least the range −32,767 to 32,767.  
- **Typical representation**: Two’s-complement on almost all modern architectures.  
- **Underlying bits**: Exactly `CHAR_BIT * sizeof(int)` bits (where `CHAR_BIT` $\ge$ 8).   

{% code_runner id="1" language="cpp" filename="int1" %}
#include <cstdio>
#include <climits>

int main() {
    printf("Size of int: %zu bytes\n", sizeof(int));
    printf("INT_MIN: %d, INT_MAX: %d\n", INT_MIN, INT_MAX);
    return 0;
}
{% endcode_runner %}

### ***3.2. Size & Range***  
- **Minimum requirements** (C99/C++11):  
  - `sizeof(int)` $\ge$ 2 bytes  
  - `INT_MIN` $\le$ −32767, `INT_MAX` $\ge$ 32767  
- **Common implementations**:  
  - 32-bit systems: `sizeof(int) == 4`, range $\approx$ $2^{15}$ to $2^{15}-1$  
  - 64-bit systems: often the same as above for LP64 models  
- **Macros**: Defined in `<climits>` / `<limits.h>`: `INT_MIN`, `INT_MAX`

{% code_runner id="2" language="cpp" filename="int2" %}
#include <stdio.h>
#include <climits>

int main(void) {
    printf("int is %zu bytes, range [%d .. %d]\n",
           sizeof(int), INT_MIN, INT_MAX);
}
{% endcode_runner %}

### ***3.3. Signed vs. Unsigned int***  
- **Signed `int`**: Range includes negative values (`INT_MIN` … `INT_MAX`).  
- **Unsigned `int`**: Range 0 … `UINT_MAX` (`2ⁿ − 1`).  
- **Conversions & promotions**: Mixed signed/unsigned expressions can lead to unexpected results due to integer promotions.

{% code_runner id="3" language="cpp" filename="overflow" %}
#include <cstdio>

int main() {
    int a = -5;
    unsigned int b = 3;
    // a + b: 'a' is converted to unsigned, causing very large result
    printf("a + b = %u\n", a + b);
    return 0;
}
{% endcode_runner %}

### ***3.4. Usage Guidelines & Pitfalls***  
- **Use `int` for general-purpose loops and counters** unless a specific range or performance concern dictates otherwise.  
- **Avoid assumptions** about byte size; rely on `sizeof(int)` and `INT_MAX`/`UINT_MAX`.  
- **Beware of overflow**: Signed overflow is undefined; unsigned overflow wraps around.  
- **Prefer `unsigned` only when non-negative values are guaranteed** and wrapping behavior is desirable.  
- **When interfacing with APIs or file formats**, match the expected width explicitly (e.g., use `int32_t` if 32-bit is required).

```cpp
// Example: prefer unsigned only when safe
for (unsigned int i = 0; i < array_length; i++) {
    // ...
}
```
---

This focused analysis of the `int` type lays the groundwork for subsequent posts on other fundamental and fixed-width integer types.
