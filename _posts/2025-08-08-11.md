---
title: "[Blog] Custom: Embed Code-Runner"
author: zerogod
date: 2025-08-08 09:38 +0900
categories: [etc, Blog]
tags: [C/C++, run, compile, execution]
render_with_liquid: true
---
## ***Abstract***
포스트 소개에 앞서, GitHub Pages 설정 및 커스텀 관련 포스트는 국내 독자와 추후 문제 해결을 위해 한글로 작성하기로 하였다.  
이번 포스트에서는 블로그 내에 **Embed Code-Runner**를 삽입하고 사용하는 방법을 정리한다. Jekyll의 Chirpy 테마를 기준으로, 별도 컴파일/실행 과정 없이 코드 예제를 바로 실행할 수 있는 환경을 구축한다.

## ***1. Introduction***
C/C++ 포스트 등에서 코드 블럭을 작성할 때, 예제 코드를 실행하려면 복사 &rarr; 컴파일 &rarr; 실행 과정을 거쳐야 한다. 이 과정이 반복되면 불필요한 시간이 소요되고 독자 역시 직접 에디터(ex. Vscode)에 코드를 옮겨야 하는 번거로움이 있다.  
이를 해소하기 위해 블로그에 **Emebed Code-Runner**를 추가하면 포스트 내에서 바로 코드 수정 및 실행이 가능하다. 이를 통해
1. 포스트 내 코드 작성이 편리해지고
1. 독자가 별도의 개발 환경을 준비할 필요가 없으며
2. 코드 수정 후 즉시 결과를 확인할 수 있는
3. 학습 및 데모에 최적화된 환경을 제공할 수 있다. 

본 포스트에서는 [OneCompiler](https://onecompiler.com/apis)의 *Embed Editor*와 *Code Executon API*, [Monaco Editor](https://microsoft.github.io/monaco-editor/), [Netlify](https://app.netlify.com/)를 연동하여 구현하였으며 각각 코드 실행, 코드 에디터, 호스팅을 담당한다. 

## ***2. Organization***
1. **Embed Code-Runner** &mdash; 기능 소개 및 사용 예제
2. **Implementation** &mdash; 구성 요소 및 설정 방법
3. **Customizaton** &mdash; 스타일 및 추가 옵션
4. **Conclusion** &mdash; 요약 및 향후 계획
5. **References** &mdash; 참고 자료

---
## ***3. Sections***
### ***3.1. Embed Code-Runner***
`render_with_liquid:` 옵션을 `true`로 설정하고, 아래 Liquid 태그를 포스트에 삽입하면 **Embed Code-Runner**가 동작한다.
{% raw %}
```liquid
{% code_runner id="hello-1" language="cpp" filename="hello" %}
#include <iostream>
int main() {
  std::cout << "Hello, World!" << std::endl;
  return 0;
}
{% endcode_runner %}
```
{% endraw %}
위 코드를 적용하면, 다음과 같이 에디터와 실행 버튼이 자동으로 렌더링된다. 

{% code_runner id="hello-1" language="cpp" filename="hello" %}
#include <iostream>
int main() {
  std::cout << "Hello, World!" << std::endl;
  return 0;
}
{% endcode_runner %}

**Embed Code-Runner**의 주요 기능을 정리하면 다음과 같다.
1. Run ▶ 버튼 클릭 시 코드 컴파일 및 실행
2. 에디터 내 직접 편집 및 재실행
3. 자동 높이 조절: 출력량에 따라 콘솔 높이 동적으로 변경
4. 스크롤 기능: 에디터·콘솔 각각 스크롤 가능
5. 다양한 언어 지원: C/C++, Python, Java 등 [Code Execution APIs](https://onecompiler.com/apis/code-execution) 참고

추가 예제:  
1) python

{% code_runner id="py1" language="python" filename="python" %}
print("Hello, World!")
print(1 + 2)
{% endcode_runner %}

2) 100줄 이상 출력 테스트

{% code_runner id="loop1" language="cpp" filename="loop" %}
#include <cstdio>
int main() {
  for (int i = 1; i <= 100; ++i) {
    printf("Line %d\n", i);
  }
  return 0;
}
{% endcode_runner %}

3) 컴파일 에러

{% code_runner id="err1" language="cpp" filename="compile_error" %}
#include <cstdio>
int main() {
  print("Hello, World!")
  return 0;
}
{% endcode_runner %}

### ***3.2. Implementation***
구현은 다음 3단계로 나뉜다.
1. [**Netlify**](https://app.netlify.com/): One Compiler API 호출 proxy
2. **JabaScript**: Monaco Editor 초기화 및 실행 로직
3. **Jekyll Plugin**: Liquid 태그 렌더링

#### **3.2.1. Netlify**
1. [RapidAPI](https://rapidapi.com/onecompiler-onecompiler-default/api/onecompiler-apis/pricing)에서 One Compiler Execution API를 활성화하고 API 키를 발급받는다. 
2. Netlify 프로젝트를 GitHub repository와 연동하여 생성한다.
3. Netlify 환경 변수(ONECOMPILER_API_KEY)로 API 키를 등록하여 배포한다.

Netlify를 이용한 proxy를 사용하는 이유는 API 키를 환경변수로 주입하는 단계에 문제가 있기 때문이다. 이를 해결하기 위해 proxy 서버를 경유하도록 구현하였으며 단순히 api 호출만을 경유하기 때문에 큰 delay가 발생하지는 않았다.   
proxy 서버의 구현은 [code-runner-proxy](https://github.com/code0-god/code-runner-proxy.git)를 참고하라.

#### ***3.2.2. JavaScript***
```js
// assets/js/code_runner.js
(function(){
  window._monacoReady = window._monacoReady ||
    new Promise(resolve => require(['vs/editor/editor.main'], resolve));

  function initEditors() {
    document.querySelectorAll('.code-runner-editor').forEach(container => {
      if (container.dataset.initialized) return;
      container.dataset.initialized = 'true';

      const id   = container.id.replace('editor-', '');
      const lang = container.dataset.lang;
      const code = JSON.parse(container.dataset.code).trim();

      const editor = monaco.editor.create(container, {
        value: code,
        language: lang,
        theme: 'vs-dark',
        automaticLayout: true,
        minimap: { enabled: false },
        scrollBeyondLastLine: false,
        renderLineHighlight: 'none'
      });

      const runBtn = document.querySelector(`.code-runner-run[data-runner-id="${id}"]`);
      runBtn.addEventListener('click', () => {
        const out = document.getElementById(`console-${id}`);
        out.textContent = 'Running…';
        
        fetch('<자신의 Netlify 주소>/.netlify/<api 호출 함수 경로와 이름>(ex. functions/run-code)', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            language: lang,
            version: 'latest',
            files: [{
              name: document.querySelector(`#runner-${id} .code-runner-filename`).textContent,
              content: editor.getValue()
            }]
          })
        })
        .then(res => res.json())
        .then(j => {
          out.textContent = j.stdout || j.output || j.errors || j.stderr || 'No output';
        })
        .catch(e => {
          out.textContent = 'Error: ' + e.message;
        });
      });
    });
  }

  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => window._monacoReady.then(initEditors));
  } else {
    window._monacoReady.then(initEditors);
  }
})();
```

#### ***3.2.3. Jekyll Plugin***
{% raw %}
```ruby
# _plugins/code_runner.rb
require 'cgi'

module Jekyll
  class CodeRunnerBlock < Liquid::Block
    SYNTAX = /(id="([^"]+)"\s+language="([^"]+)"(?:\s+filename="([^"]+)")?)/

    def initialize(tag_name, markup, tokens)
      super
      unless markup =~ SYNTAX
        raise SyntaxError,
          "Valid syntax: {% code_runner id=\"foo\" language=\"cpp\" [filename=\"bar\"] %}"
      end
      @id, @language, @filename = $2, $3, $4
    end

    def render(context)
      code = super.strip
      fname = @filename.to_s.empty? ?
                 "main.#{@language}" :
                 @filename.include?('.') ? @filename : "#{@filename}.#{@language}"
      json_code = CGI.escapeHTML(code.to_json)

      <<~HTML
      <div class="code-runner-wrapper" id="runner-#{@id}">
        <div class="code-runner-header">
          <span class="code-runner-filename">#{fname}</span>
          <button class="code-runner-run" data-runner-id="#{@id}">Run ▶</button>
        </div>
        <div id="editor-#{@id}" class="code-runner-editor"
             data-code='#{json_code}'
             data-lang='#{@language}'></div>
        <pre id="console-#{@id}" class="code-runner-console">Click Run ▶</pre>
      </div>
      HTML
    end
  end
end

Liquid::Template.register_tag('code_runner', Jekyll::CodeRunnerBlock)
```
{% endraw %}

### ***3.3. Customization***
#### **3.3.1. head.html**
*Monaco Editor* 사용을 위해 head.html에서 `<script src="{{ '/assets/js/dist/theme.min.js' | relative_url }}"></script>
` 아래 다음 두 script를 추가한다

```html
  <script src="{{ '/assets/js/dist/theme.min.js' | relative_url }}"></script>

<!-- 1) Monaco AMD 로더 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs/loader.js"></script>
  <script>
    require.config({
      paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs' }
    });
  </script>

  <!-- 2) CodeRunner 초기화 -->
  <script src="{{ '/assets/js/code_runner.js' | relative_url }}"></script>
```
#### **3.3.2. CSS**
```scss
// _sass/_code-runner.scss
.code-runner-wrapper {
  border: 1px solid #444;
  border-radius: 8px;
  background: #232323;
  overflow: hidden;
  margin-bottom: 2em;
  box-shadow: 0 4px 12px rgba(0,0,0,0.5);
  display: flex;
  flex-direction: column;
}

/* ─── HEADER ──── */
.code-runner-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 0.6em 1em;
  background: linear-gradient(135deg, #2b2b2b, #1f1f1f);
  border-bottom: 1px solid #555;
}

.code-runner-filename {
  font-family: 'Source Code Pro', monospace;
  font-size: 1em;
  font-weight: 500;
  color: #e0e0e0;
  user-select: none;
  margin: 0;
}

.code-runner-run {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: 0.5em 0.8em;
  line-height: 1;
  background: #d43f5a;
  color: #fff;
  border: 1px solid #ad3246;
  border-radius: 4px;
  font-size: 0.8em;
  font-weight: 500;
  cursor: pointer;
  transition: background .2s, border-color .1s;
}

.code-runner-run:hover {
  background: #ad3246;
  border-color: #8b2938;
}

/* ─── EDITOR ──── */
.code-runner-editor {
  background: #1e1e1e;
  /* 헤더 아래 상단 패딩만 주기 */
  padding-top: 0.75rem;
  min-height: 180px;
  position: relative;
}

/* Monaco 에디터 컨테이너 높이와 스크롤 제어 */
.code-runner-editor .monaco-editor,
.code-runner-editor .monaco-editor .overflow-guard {
  background: #1e1e1e !important;
}

.code-runner-editor .monaco-editor,
.code-runner-editor .monaco-editor .overflow-guard {
  background: #1e1e1e !important;
}
.code-runner-editor .monaco-editor,
.code-runner-editor .monaco-editor .overflow-guard {
  background: #1e1e1e !important;
}

/* ─── CONSOLE ─── */
.code-runner-console {
  padding: 1rem;
  background: #111;
  color: #0f0;
  font-family: monospace;
  font-size: 0.8em;
  border-top: 1px solid #555;
  min-height: 100px;
  max-height: 200px;
  overflow: auto;
}

/* 커스텀 스크롤바 */
.code-runner-editor::-webkit-scrollbar,
.code-runner-console::-webkit-scrollbar {
  width: 6px;
}
.code-runner-editor::-webkit-scrollbar-thumb,
.code-runner-console::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.15);
  border-radius: 3px;
}
```

생성한 css를 `main.scss`에 추가해주면 Embed Code-Runner가 적용된다.
```scss
// main.scss
@forward 'base';
@forward 'components';
@forward 'layout';
@forward 'pages';
@forward "code-runner"; // 추가
```

### ***3.4. Conclusion***
이번 포스트에서는 **Embed Code-Runner**의 전체 구축 과정을 다루었다. 주요 장점은 학습 및 데모 환경에서의 효율성 증대이며, 단점은 아직 구현이 미흡하다는 점이다. 

향후 계획:
1. 에디터 크기 동적 변경
2. 디자인 개선
3. 언어별 확장자 자동 매핑 (ex. python &rarr; py)

### ***3.5. References***
1. [OneCompiler](https://onecompiler.com/)
2. [Monaco Editor를 활용해서 React 기반 프로젝트에 코드 에디터 적용하기!](https://mingule.tistory.com/75)
3. [Monaco Editor](https://microsoft.github.io/monaco-editor/)
4. [Netlify](https://app.netlify.com/)