---
title: "[C/C++] User-defined Macro(1): Basics"
author: zerogod
date: 2025-07-29 05:52 +0900
categories: [C/C++, Macro]
tags: [C/C++, macro]
render_with_liquid: false
---
## ***Abstract***
This post introduces the fundamental concepts and usage patterns of ***user-defined macros*** in C and C++.   
It covers macro constants, function-like macros, and the hazards associated with multiple evaluation.

## ***1. Introduction***
In C and C++, ***macros*** are handled by the preprocessor, performing ***simple textual substitution*** before compilation.   
While this mechanism can enhance code brevity and reuse, it can also produce unintended side effects and lead to undefined behavior when macro arguments include expressions with side effects. This article is aimed at beginners and explains how macro constants and function-like macros operate, as well as recommended practices to avoid common pitfalls.

## ***2. Organization***
1. **What is a Macro?** &mdash; Definition and preprocessor-level operation   
2. **Basic Syntax** &mdash; Defining macro constants using `#define`     
3. **Macro Function** &mdash; Implementing function-like macros and the critical importance of parentheses     
4. **Pitfalls of Multiple Evaluation** &mdash; Case studies of multiple evaluation issues and side-effect risks     
5. **Next** &mdash; Link to the advanced macro features post

---
## ***3. Sections***
### ***3.1. What is a Macro?***
A ***macro*** is a preprocessor directive that performs **string substitution** before the source code is compiled.   
It is interpreted by the ***preprocessor***, not by the ***compiler***.   

### ***3.2. Basic Syntax***
> \#define *identifier* *value*

The `#define` directive is used to define an ***identifier*** as a ***value***. The '\#' symbol indicates that this line will be preprocessed by the preprocessor.   

An ***identifier*** defined in this way is called a ***Macro Constant*** and can be used as shown below:
```cpp
#define PI 3.141592
#define BUFFER_SIZE 1024

int main() {
        printf("PI: %f\n", PI);
        printf("BUFFER_SIZE: %d\n", BUFFER_SIZE);

        return 0;
}
```
```bash
PI: 3.141592
BUFFER_SIZE: 1024
```

### ***3.3. Macro Function***
A macro can also be defined as a function-like expression: 
```cpp
#define SQUARE(x) ((x) * (x))
#define CUBE(x) ((x) * (x) * (x))
#include <cstdio>

int main() {
        int x = 5;
        printf("Square of %d is %d\n", x, SQUARE(x));
        printf("Cube of %d is %d\n", x, CUBE(x));

        return 0;
}
```
```bash
Square of 5 is 25
Cube of 5 is 125
```
Note that **parentheses** are essential in the body of a macro function. This is because the preprocessor performs a ***simple textual substitution*** and does not evaluate expressoins like a compiler does.   
Consider the following example, which lacks proper parentheses:
```cpp
#define SQUARE(x) x * x
#define CUBE(x) x * x * x
#include <cstdio>

int main()  {
        printf("Square of (1 + 2) is %d\n", SQUARE(1 + 2));
        printf("Cube of (1 + 2) is %d\n", CUBE(1 + 2));

        return 0;
} 
```
```bash
Square of (1 + 2) is 5
Cube of (1 + 2) is 7
```
In the example above, `SQARE(1 + 2)` is expanded as  `1 + 2 * 1 + 2`, which is evaluated as `1 + (2 * 1) + 2 = 5`.   
Likewise, `CUBE(1 + 2)` becomes `1 + 2 * 1 + 2 * 1 + 2`, which also gives an incorrect result.

Therefore, always use **parentheses** around both the parameters and the entire body of a macro function to ensure correct evalutation.

### ***3.4. Pitfalls of multiple evaluation***
Consider the following example:
```cpp
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#include <cstdio>

int main() {
        int x = 6, y = 5;
        printf("Max of %d and %d is %d\n", x, y, MAX(x++, y));
        printf("Max of %d and %d is %d\n", y, x, MAX(y, x));
        
        return 0;
}
```
```bash
Max of 8 and 5 is 7
Max of 5 and 8 is 8
```
The result is **unexpected**.   
This happens because the ***preprocessor performs simple textual substitution*** without any concern for side effects or evaluation count. 

In the first call:  
`MAX(x++, y)` &rarr; `((x++) > (y) ? (x++) : (y))`   
Here, if `x++ > y` evaluates to true, then `x++` is executed again as the return value, meaning `x++` is evaluated twice.
This causes `x` to be incremented more than once in a single expression, which can result in undefined behavior in C/C++.

### ***3.5. Next***
> Next: [User-defined Macro(2): Advanced](https://code0-god.github.io/posts/6/)
