---
title: "[C/C++] User-defined Macro(1): Basics"
author: zerogod
date: 2025-07-29 05:52
categories: [C/C++, Macro]
tags: [C/C++, macro]
render_with_liquid: false
---
## ***What is a Macro?***
A ***macro*** is a preprocessor directive that performs **string substitution** before the source code is compiled.   
It is interpreted by the ***preprocessor***, not by the ***compiler***.   

## ***Basic Syntax***
> \#define *identifier* *value*

The `#define` directive is used to define an ***identifier*** as a ***value***. The '\#' symbol indicates that this line will be preprocessed by the preprocessor.   

An ***identifier*** defined in this way is called a ***Macro Constant*** and can be used as shown below:
```cpp
#define PI 3.141592
#define BUFFER_SIZE 1024

int main() {
        printf("PI: %f\n", PI);
        printf("BUFFER_SIZE: %d\n", BUFFER_SIZE);

        return 0;
}
```
```bash
PI: 3.141592
BUFFER_SIZE: 1024
```

## ***Macro Function***
A macro can also be defined as a function-like expression: 
```cpp
#define SQUARE(x) ((x) * (x))
#define CUBE(x) ((x) * (x) * (x))
#include <cstdio>

int main() {
        int x = 5;
        printf("Square of %d is %d\n", x, SQUARE(x));
        printf("Cube of %d is %d\n", x, CUBE(x));

        return 0;
}
```
```bash
Square of 5 is 25
Cube of 5 is 125
```
Note that **parentheses** are essential in the body of a macro function. This is because the preprocessor performs a ***simple textual substitution*** and does not evaluate expressoins like a compiler does.   
Consider the following example, which lacks proper parentheses:
```cpp
#define SQUARE(x) x * x
#define CUBE(x) x * x * x
#include <cstdio>

int main()  {
        printf("Square of (1 + 2) is %d\n", SQUARE(1 + 2));
        printf("Cube of (1 + 2) is %d\n", CUBE(1 + 2));

        return 0;
} 
```
```bash
Square of (1 + 2) is 5
Cube of (1 + 2) is 7
```
In the example above, `SQARE(1 + 2)` is expanded as  `1 + 2 * 1 + 2`, which is evaluated as `1 + (2 * 1) + 2 = 5`.   
Likewise, `CUBE(1 + 2)` becomes `1 + 2 * 1 + 2 * 1 + 2`, which also gives an incorrect result.

Therefore, always use **parentheses** around both the parameters and the entire body of a macro function to ensure correct evalutation.

## ***Pitfalls of multiple evalutaion***
Consider the following example:
```cpp
#define MAX(a, b) ((a) > (b) ? (a) : (b))
#include <cstdio>

int main() {
        int x = 6, y = 5;
        printf("Max of %d and %d is %d\n", x, y, MAX(x++, y));
        printf("Max of %d and %d is %d\n", y, x, MAX(y, x));
        
        return 0;
}
```
```bash
Max of 8 and 5 is 7
Max of 5 and 8 is 8
```
The result is **unexpected**.   
This happens because the ***preprocessor performs simple textual substitution*** without any concern for side effects or evaluation count. 

In the first call:  
`MAX(x++, y)` &rarr; `((x++) > (y) ? (x++) : (y))`   
Here, if `x++ > y` evaluates to true, then `x++` is executed again as the return value, meaning `x++` is evaluated twice.
This causes `x` to be incremented more than once in a single expression, which can result in undefined behavior in C/C++.


> Next: [User-defined Macro(2): Advanced](https://code0-god.github.io/posts/6/)
