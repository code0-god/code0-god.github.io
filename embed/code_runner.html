<!-- embed/code_runner.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Code Runner</title>

  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; background:#1e1e1e; overflow:hidden; }
    #container { width:100%; background:#1e1e1e; }
    .monaco-editor .overflow-guard { overflow-x:auto !important; }
    .monaco-editor .monaco-scrollable-element .scrollbar > .slider { background:rgba(128,128,128,0.30) !important; border-radius:3px !important; }
    .monaco-editor .monaco-scrollable-element .scrollbar:hover > .slider { background:rgba(128,128,128,0.50) !important; }
    .monaco-editor .monaco-scrollable-element .scrollbar > .slider.active { background:rgba(128,128,128,0.70) !important; }
  </style>

  <!-- Monaco AMD 로더 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs/loader.js"></script>

  <script>
    /* global require, monaco */

    require.config({
      paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs' }
    });

    function parseUrlParams() {
      const url = new URL(window.location.href);
      return {
        lang: (url.searchParams.get('lang') || 'cpp').trim(),
        runnerId: (url.searchParams.get('id') || '').trim()
      };
    }

    function getEditorVPadPx() {
      try {
        const iframeEl = window.frameElement;
        if (iframeEl && iframeEl.parentElement) {
          const host = iframeEl.parentElement;
          const parentWindow = (iframeEl.ownerDocument || document).defaultView;
          const cs = parentWindow.getComputedStyle(host);
          let val = cs.getPropertyValue('--editor-vpad').trim();
          if (!val) val = '0.75em';
          const hostFontPx = parseFloat(cs.fontSize) || 16;
          if (val.endsWith('rem')) {
            const rootFs = parseFloat(parentWindow.getComputedStyle(
              (iframeEl.ownerDocument || document).documentElement
            ).fontSize) || 16;
            return Math.round(parseFloat(val) * rootFs);
          }
          if (val.endsWith('em')) return Math.round(parseFloat(val) * hostFontPx);
          if (val.endsWith('px')) return Math.round(parseFloat(val));
          const n = parseFloat(val);
          return Number.isNaN(n) ? 12 : Math.round(n);
        }
      } catch (e) {}
      return 12;
    }

    function normalizeLangId(input) {
      const raw = (input || '').toLowerCase();
      const map = {
        'c++':'cpp', 'c#':'csharp', 'cs':'csharp',
        'py':'python', 'js':'javascript', 'ts':'typescript',
        'sh':'bash', 'shell':'bash',
        'plaintext':'text', 'text':'text',
        'kt':'kotlin', 'rs':'rust'
      };
      return map[raw] || raw;
    }

    let editor;
    let fileModels = {}; // Stores Monaco models for each file
    let currentFilename = '';

    require(['vs/editor/editor.main'], async function () {
      const { lang: urlLang, runnerId } = parseUrlParams();
      const initialLang = normalizeLangId(urlLang || 'cpp');
      const container = document.getElementById('container');


      const [
        { shikiToMonaco },
        { createHighlighter },
        { createJavaScriptRegexEngine }
      ] = await Promise.all([
        import('https://esm.sh/@shikijs/monaco@3.9.2'),
        import('https://esm.sh/shiki@3.9.2'),
        import('https://esm.sh/shiki@3.9.2/engine/javascript')
      ]);

      const highlighter = await (window._shikiHighlighterPromise ||= (async () => {
        return await createHighlighter({
          themes: ['dark-plus'],
          langs: [initialLang],
          engine: createJavaScriptRegexEngine()
        });
      })());

      if (!monaco.languages.getLanguages().some(l => l.id === initialLang)) {
        monaco.languages.register({ id: initialLang });
      }
      shikiToMonaco(highlighter, monaco);

      const vpad = getEditorVPadPx();
      editor = monaco.editor.create(container, {
        value: '',
        language: initialLang,
        theme: 'dark-plus',
        automaticLayout: false,
        minimap: { enabled: false },
        wordWrap: 'off',
        scrollBeyondLastColumn: 4,
        renderLineHighlight: 'none',
        scrollBeyondLastLine: false,
        padding: { top: vpad, bottom: vpad },
        scrollbar: {
          vertical: 'hidden',
          horizontal: 'auto',
          verticalScrollbarSize: 0,
          horizontalScrollbarSize: 6,
          handleMouseWheel: true,
          alwaysConsumeMouseWheel: false,
          useShadows: false
        }
      });

      function resizeToFit() {
        const contentHeight = editor.getContentHeight();
        const width = container.clientWidth || editor.getLayoutInfo().width || 0;
        const h = Math.max(1, contentHeight); // 0 방지
        editor.layout({ width, height: h });
        container.style.height = String(h) + 'px';
        if (window.parent && window.frameElement) {
          window.frameElement.style.height = String(h + 2) + 'px';
        }
      }
      editor.onDidContentSizeChange(resizeToFit);
      window.addEventListener('resize', resizeToFit);

      // === VSCode 스타일: 네이티브 수직 스크롤 유지(관성), 에디터 수평만 허용 ===
      // 캡처 + 패시브: 브라우저 스크롤 파이프라인(Compositor) 방해 X
      const onWheelCapture = (e) => {
        // 코드 에디터 영역 외면 무시
        if (!container.contains(e.target)) return;
        if (e.ctrlKey) return; // 확대/축소 제스처 그대로
        const ax = Math.abs(e.deltaX), ay = Math.abs(e.deltaY);
        const horizIntent = e.shiftKey || (ax > ay * 1.1); // 10% 지터 보정
        if (!horizIntent) {
          // 수직 스크롤: 에디터에 전달하지 않음(버블 차단만)
          // 기본 동작(페이지 스크롤)은 브라우저가 처리 → 아주 부드러움
          e.stopPropagation();
          // 절대 preventDefault() 하지 마세요!
        }
        // 수평 스크롤은 통과 → Monaco가 가로 스크롤 처리
      };
      window.addEventListener('wheel', onWheelCapture, { capture: true, passive: true });

      // 부모가 보내는 초기화 메시지 처리
      window.addEventListener('message', async (event) => {
        const data = event.data;
        if (!data || data.type !== 'init' || data.id !== runnerId) return;

        const langId = normalizeLangId(data.lang || initialLang);
        const files = data.files || [];

        // Create models for all files
        fileModels = {};
        files.forEach(file => {
          const model = monaco.editor.createModel(file.content, langId, monaco.Uri.file(file.name));
          fileModels[file.name] = model;
        });

        // Set the editor to display the first file
        if (files.length > 0) {
          editor.setModel(fileModels[files[0].name]);
          currentFilename = files[0].name;
        }

        resizeToFit();
      }, false);

      // 동일 출처일 때의 폴백: 부모 DOM의 JSON 스크립트에서 읽기
      try {
        const parentDoc = window.frameElement ? window.frameElement.ownerDocument : null;
        const holder = parentDoc && parentDoc.getElementById(`cr-code-${runnerId}`);
        if (holder && holder.textContent) {
          const payload = JSON.parse(holder.textContent);
          const langId = normalizeLangId((payload && payload.language) || initialLang);
          const files = (payload && payload.files) || [];

          fileModels = {};
          files.forEach(file => {
            const model = monaco.editor.createModel(file.content, langId, monaco.Uri.file(file.name));
            fileModels[file.name] = model;
          });

          if (files.length > 0) {
            editor.setModel(fileModels[files[0].name]);
            currentFilename = files[0].name;
          }
          resizeToFit();
        }
      } catch (e) {
        // same-origin이 아니거나 JSON 파싱 실패 시 무시
      }

      // 파일 전환 요청 처리 (부모 -> 자식)
      window.addEventListener('message', function (event) {
        const data = event.data;
        if (!data || data.type !== 'switch-file' || data.id !== runnerId) return;

        const filenameToSwitch = data.filename;
        if (fileModels[filenameToSwitch]) {
          editor.setModel(fileModels[filenameToSwitch]);
          currentFilename = filenameToSwitch;
          resizeToFit();
        }
      }, false);

      // 모든 파일 내용 요청 처리 (부모 -> 자식)
      window.addEventListener('message', function (event) {
        const data = event.data;
        if (!data || data.type !== 'get-all-files' || data.id !== runnerId) return;

        const updatedFiles = Object.keys(fileModels).map(name => ({
          name: name,
          content: fileModels[name].getValue()
        }));
        window.parent.postMessage({ type: 'all-files-result', id: runnerId, files: updatedFiles }, '*');
      }, false);

      // 실행 요청 처리 (부모 -> 자식)
      window.addEventListener('message', function (event) {
        const data = event.data;
        if (!data || data.type !== 'run' || data.id !== runnerId) return;

        const langId = normalizeLangId(data.lang || initialLang);
        const filesToRun = data.files; // Now receives all files from parent

        fetch('https://ornate-beijinho-0548f2.netlify.app/.netlify/functions/run-code', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            language: langId,
            version: 'latest',
            files: filesToRun
          })
        })
        .then(res => res.json())
        .then(j => {
          const parts = [j.stdout, j.stderr, j.errors, j.output]
            .map(x => (x==null ? '' : String(x))).filter(x => x.trim() !== '');
          const output = parts.join('\n') || 'No output';
          window.parent.postMessage({ type: 'run-result', id: runnerId, output }, '*');
        })
        .catch(e => {
          window.parent.postMessage({ type: 'run-result', id: runnerId, output: 'Error: ' + e.message }, '*');
        });
      }, false);
    });
  </script>
</head>
<body>
  <div id="container"></div>
</body>
</html>