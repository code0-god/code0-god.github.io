<!-- embed/code_runner.html -->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Code Runner</title>

  <style>
    html, body { margin:0; padding:0; width:100%; height:100%; background:#1e1e1e; overflow:hidden; }
    #container { width:100%; background:#1e1e1e; }
    .monaco-editor .overflow-guard { overflow-x:auto !important; }
    .monaco-editor .monaco-scrollable-element .scrollbar > .slider { background:rgba(128,128,128,0.30) !important; border-radius:3px !important; }
    .monaco-editor .monaco-scrollable-element .scrollbar:hover > .slider { background:rgba(128,128,128,0.50) !important; }
    .monaco-editor .monaco-scrollable-element .scrollbar > .slider.active { background:rgba(128,128,128,0.70) !important; }
  </style>

  <!-- Monaco AMD 로더 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs/loader.js"></script>

  <script>
    /* global require, monaco */

    require.config({
      paths: { vs: 'https://cdnjs.cloudflare.com/ajax/libs/monaco-editor/0.33.0/min/vs' }
    });

    function parseUrlParams() {
      const url = new URL(window.location.href);
      return {
        lang: (url.searchParams.get('lang') || 'cpp').trim(),
        filename: (url.searchParams.get('filename') || 'main.cpp').trim(),
        runnerId: (url.searchParams.get('id') || '').trim()
      };
    }

    function getEditorVPadPx() {
      try {
        const iframeEl = window.frameElement;
        if (iframeEl && iframeEl.parentElement) {
          const host = iframeEl.parentElement;
          const parentWindow = (iframeEl.ownerDocument || document).defaultView;
          const cs = parentWindow.getComputedStyle(host);
          let val = cs.getPropertyValue('--editor-vpad').trim();
          if (!val) val = '0.75em';
          const hostFontPx = parseFloat(cs.fontSize) || 16;
          if (val.endsWith('rem')) {
            const rootFs = parseFloat(parentWindow.getComputedStyle(
              (iframeEl.ownerDocument || document).documentElement
            ).fontSize) || 16;
            return Math.round(parseFloat(val) * rootFs);
          }
          if (val.endsWith('em')) return Math.round(parseFloat(val) * hostFontPx);
          if (val.endsWith('px')) return Math.round(parseFloat(val));
          const n = parseFloat(val);
          return Number.isNaN(n) ? 12 : Math.round(n);
        }
      } catch (e) {}
      return 12;
    }

    function normalizeLangId(input) {
      const raw = (input || '').toLowerCase();
      const map = {
        'c++':'cpp', 'c#':'csharp', 'cs':'csharp',
        'py':'python', 'js':'javascript', 'ts':'typescript',
        'sh':'bash', 'shell':'bash',
        'plaintext':'text', 'text':'text',
        'kt':'kotlin', 'rs':'rust'
      };
      return map[raw] || raw;
    }

    require(['vs/editor/editor.main'], async function () {
      const { lang: urlLang, filename: urlFilename, runnerId } = parseUrlParams();
      const initialLang = normalizeLangId(urlLang || 'cpp');
      const initialFilename = urlFilename || 'main.cpp';
      const container = document.getElementById('container');

      const MIN_HEIGHT = 50, MAX_HEIGHT = 380;

      const [
        { shikiToMonaco },
        { createHighlighter },
        { createJavaScriptRegexEngine }
      ] = await Promise.all([
        import('https://esm.sh/@shikijs/monaco@3.9.2'),
        import('https://esm.sh/shiki@3.9.2'),
        import('https://esm.sh/shiki@3.9.2/engine/javascript')
      ]);

      const highlighter = await (window._shikiHighlighterPromise ||= (async () => {
        return await createHighlighter({
          themes: ['dark-plus'],
          langs: [initialLang],
          engine: createJavaScriptRegexEngine()
        });
      })());

      if (!monaco.languages.getLanguages().some(l => l.id === initialLang)) {
        monaco.languages.register({ id: initialLang });
      }
      shikiToMonaco(highlighter, monaco);

      const vpad = getEditorVPadPx();
      window.editor = monaco.editor.create(container, {
        value: '',
        language: initialLang,
        theme: 'dark-plus',
        automaticLayout: false,
        minimap: { enabled: false },
        wordWrap: 'off',
        scrollBeyondLastColumn: 4,
        renderLineHighlight: 'none',
        scrollBeyondLastLine: false,
        padding: { top: vpad, bottom: vpad },
        scrollbar: {
          vertical: 'auto',
          horizontal: 'auto',
          verticalScrollbarSize: 6,
          horizontalScrollbarSize: 6,
          handleMouseWheel: true,
          useShadows: false
        }
      });

      function resizeToFit() {
        const contentHeight = window.editor.getContentHeight();
        const bounded = Math.max(MIN_HEIGHT, Math.min(contentHeight, MAX_HEIGHT));
        const width = container.clientWidth || window.editor.getLayoutInfo().width || 0;
        window.editor.layout({ width, height: bounded });
        container.style.height = String(bounded) + 'px';
        if (window.parent && window.frameElement) {
          window.frameElement.style.height = String(bounded + 2) + 'px';
        }
      }
      window.editor.onDidContentSizeChange(resizeToFit);

      // 부모가 보내는 초기화 메시지 처리
      window.addEventListener('message', async (event) => {
        const data = event.data;
        if (!data || data.type !== 'init' || data.id !== runnerId) return;

        const langId = normalizeLangId(data.lang || initialLang);
        if (!monaco.languages.getLanguages().some(l => l.id === langId)) {
          monaco.languages.register({ id: langId });
        }
        const model = window.editor.getModel();
        if (model) { monaco.editor.setModelLanguage(model, langId); }
        window.editor.setValue(String(data.code || ''));
        resizeToFit();
      }, false);

      // 동일 출처일 때의 폴백: 부모 DOM의 JSON 스크립트에서 읽기
      try {
        const parentDoc = window.frameElement ? window.frameElement.ownerDocument : null;
        const holder = parentDoc && parentDoc.getElementById(`cr-code-${runnerId}`);
        if (holder && holder.textContent) {
          const payload = JSON.parse(holder.textContent);
          const langId = normalizeLangId((payload && payload.lang) || initialLang);
          if (!monaco.languages.getLanguages().some(l => l.id === langId)) {
            monaco.languages.register({ id: langId });
          }
          const model = window.editor.getModel();
          if (model) { monaco.editor.setModelLanguage(model, langId); }
          window.editor.setValue(String((payload && payload.code) || ''));
          resizeToFit();
        }
      } catch (e) {
        // same-origin이 아니거나 JSON 파싱 실패 시 무시
      }

      // 실행 요청 처리 (부모 -> 자식)
      window.addEventListener('message', function (event) {
        const data = event.data;
        if (!data || data.type !== 'run' || data.id !== runnerId) return;

        const langId = normalizeLangId(data.lang || initialLang);
        const filename = data.filename || initialFilename;
        const codeToRun = window.editor.getValue();

        fetch('https://ornate-beijinho-0548f2.netlify.app/.netlify/functions/run-code', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            language: langId,
            version: 'latest',
            files: [{ name: filename, content: codeToRun }]
          })
        })
        .then(res => res.json())
        .then(j => {
          const parts = [j.stdout, j.stderr, j.errors, j.output]
            .map(x => (x==null ? '' : String(x))).filter(x => x.trim() !== '');
          const output = parts.join('\n') || 'No output';
          window.parent.postMessage({ type: 'run-result', id: runnerId, output }, '*');
        })
        .catch(e => {
          window.parent.postMessage({ type: 'run-result', id: runnerId, output: 'Error: ' + e.message }, '*');
        });
      }, false);
    });
  </script>
</head>
<body>
  <div id="container"></div>
</body>
</html>
